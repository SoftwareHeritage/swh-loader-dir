#!/usr/bin/env python3

# Copyright (C) 2015  The Software Heritage developers
# See the AUTHORS file at the top-level directory of this distribution
# License: GNU General Public License version 3, or any later version
# See top-level LICENSE file for more information

import sys
import os

from swh.core import config
from swh.loader.dir import producer


# Static setup
EPOCH = 0
UTC_OFFSET = '+0000'
SWH_PERSON = 'Software Heritage'
SWH_MAIL = 'robot@swh.org'
REVISION_MESSAGE = 'synthetic message'
REVISION_TYPE = 'tar'
REVISION = {
    'author_date': EPOCH,
    'author_offset': UTC_OFFSET,
    'author_name': SWH_PERSON,
    'author_email': SWH_MAIL,
    'committer_date': EPOCH,
    'committer_offset': UTC_OFFSET,
    'committer_name': SWH_PERSON,
    'committer_email': SWH_MAIL,
    'type': REVISION_TYPE,
    'message': REVISION_MESSAGE,
}
SWH_AUTHORITY = 1
GNU_AUTHORITY = 2


def compute_origin(config, filename):
    """Compute the origin.

    Args:
        - config:
        - filename:

    Returns:
        Dictionary origin with keys:
       - url: origin's url
       - type: origin's type

    """
    return {
        'url': os.path.join(config['url_scheme'], filename),
        'type': config['type'],
    }


def swh_occurrence(filepath):
    """Compute the occurrence from the filepath with swh authority.

    Args:
        filepath: file's path

    Return:
        Occurrence.
        - branch: occurrence's branch name
        - authority: swh authority
        - validity: validity date (e.g. 2015-01-01 00:00:00+00)

    """
    return {
        'branch': os.path.dirname(filepath),
        'authority': SWH_AUTHORITY,
        'validity': time_from_file(filepath)  # FIXME: Use the right time
    }


def gnu_occurrence(filepath):
    """Compute the occurrence from the filepath with gnu authority.

    Args:
        filepath: file's path

    Return:
        Occurrence.

    """
    return {
        'branch': os.path.dirname(filepath),
        'authority': GNU_AUTHORITY,
        'validity': time_from_file(filepath)
    }


def compute_occurrences(filepath):
    """Compute the occurrences from filepath.

    Args:
        filepath:

    Returns:
        list of occurrences from filepath.

    """
    return [gnu_occurrence(filepath), swh_occurrence(filepath)]


def time_from_file(filepath):
    """Extract time from filepath.

    Args:
        filepath: path to the file we want to extract metadata

    Returns:
        Modification time from filepath.

    """
    return os.lstat(filepath).st_mtime


def compute_release(filepath):
    """Compute a release from a given filepath.
    If the filepath does not contain a recognizable release number, the release
    can be skipped.

    Args:
        filepath: file's absolute path

    Returns:
        None if the release number cannot be extracted from the filename.
        Otherwise a synthetic release is computed with the following keys:
            - name: the release computed from the filename
            - date: the modification timestamp as returned by a fstat call
            - offset: +0000
            - author_name: ''
            - author_email: ''
            - comment: ''

    """
    filename = os.path.basename(filepath)
    release_number = producer.release_number(filename)
    if release_number:
        return {
            'name': release_number,
            'date': time_from_file(filepath),
            'offset': UTC_OFFSET,
            'author_name': '',
            'author_email': '',
            'comment': '',
        }
    return None


def compute_revision(filepath):
    """Compute the revision from filepath.

    Args:
        filepath: file's absolute path

    Returns:
        Synthetic revision.

    """
    return REVISION


def list_archives_from(path):
    """From path, produce archive tarball message to celery.

    Args:
        path: top directory to list archives from.

    """
    for dirpath, dirnames, filenames in os.walk(path):
        for fname in [f for f in filenames if producer.is_archive(f)]:
            yield dirpath, fname


# LIMIT = 100
LIMIT = None


def compute_message_from(dirpath, filename):
    # filepath = os.path.join(dirpath, filename)

    version = producer.release_number(filename)
    print('|'.join(['', filename, version, '']))


def produce_archive_messages(path):
    """From path, produce archive tarball message to celery.

    Args:
        path: top directory to list archives from.

    """
    limit = 0
    for dirpath, filename in list_archives_from(path):
        compute_message_from(dirpath, filename)
        if LIMIT and limit > LIMIT:
            return
        limit += 1


conf_file = sys.argv[1]
if not os.path.exists(conf_file):
    conf_file = '../resources/producer/tar.ini'

conf = config.read(conf_file)

produce_archive_messages(conf['mirror_root_directory'])
